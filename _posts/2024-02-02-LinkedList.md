---
layout : post
title : Linked List
---
# 정의
> 각 노드들이 연결된 자료구조

## 노드의 구성
1. 데이터 : 자료구조니까 자료를 저장하는 공간이 당연히 필요함.

2. 연결된 노드의 주소 : 노드 간의 연결을 위해서 연결된 노드의 주소를 
가지고 있어야 됨.

# 특징

1. 노드에 접근

- 노드를 통해서 다음 노드로 접근하기때문에, O(N)의 시간복잡도를 가짐.

2. 노드 삽입/제거

- 전후 노드의 노드의 주소만 바꾸면 삽입/제거가 됨

- 삽입/제거할 노드에 접근했다면, O(1)의 시간복잡도

- 노드를 주로 메모리 할당을 받기 때문에 노드 제거시에는 할당 해제를 해야 메모리 누수를 막을 수 있음.

# 종류

## singly vs doubly Linked List

- 노드가 한 방향으로만 연결되면 singly

- 노드가 두 방향으로 연결되면 doubly

## circular Linke List

- 노드의 마지막이 노드의 처음과 연결되어 있으면 circular

### 작명은 하기 나름..

# 구현

1. 구조체/클래스로 노드 구현
    - 정석적인 방식
2. data, next, prev와 같이 각 노드를 배열로서 관리
    - 메모리 낭비/ 빠르게 구현 가능

# STL list
> #include \<list>

- doubly linked list
    - 마지막 노드는 **더미노드**

- std::list<~>::iterator로 iterator 제공

- my_list.end()는 **더미노드** iterator 반환

- 나머지 insert, erase 등은 reference 참고

# Linked List 관련 문제

## 두 리스트가 합쳐지는 노드 찾기

- 서로 다른 길이의 linked list 1, 2가 특정 노드부터는 같은 노드들을 공유한다.

- 이때 list 1, 2의 임의의 시작점에서 출발 할 때 어디에서부터 같은 노드를 공유하는지를 찾는 문제.

### 답

- 각각 list의 길이를 구한 후

- 더 긴 쪽의 리스트의 커서를 짧은 쪽의 길이과 같게 옮긴 후 같은 노드가 나올 때 까지 커서를 하나씩 옮기며 탐색

## floyd's circle finding algorithm

- 주어진 리스트가 circle을 포함하는지 판단하는 알고리즘

- 시작 노드에서 커서1은 한 노드씩, 커서2는 두 노드씩 움직임
    - circle이 있으면 두 커서는 만남

    - circle이 없으면 커서2가 먼저 end에 도착

# 백준 삽질...
"\b"는 \b를 출력하는 것일 뿐...백준에서 백스페이스가 아니다.