---
layout : post
title : edge case
---

# OUT OF BOUNDS

### 문제 발생 시점
- BOJ 3273번을 풀던 중 런타임에서 Out Of Bounds 에러로 오답이 발생.

### 디버깅 방법
- 배열의 인덱스를 넘어버려서 발생한 에러

- 내가 사용하는 배열 중 어디에서 발생한지를 파악해야된다.

- 아래와 같이 배열의 인덱스에 대해서 덧셈, 뺄셈 연산을 하게 되면 최대/최소 케이스에 대한 인덱스를 파악하기 힘들다

```
else if (exist[x - num[i]] == true)
```

- 여기에서 x의 범위와 num[i]의 범위를 고려해서 exist의 인덱스 범위를 벗어나는지 체크를 먼저 해봤으면 디버깅을 빨리 할 수 있었을 것이다.


# 나머지에 따라 다른 경우 처리방법

### 문제
- n명의 투숙객을 한 방 최대수용인원이 k명일때 최소로 예약할 수 있는 방의 개수

`예시 : 7명의 투숙객인 경우에 대해서`
### 나의 경우
- k = 1 or k = 7, 즉 k로 나눴을 때 나누어 떨어지는 경우/ 아닌 경우로 나눠서
    - n / k or n / k + 1을 각각 조건문에서 연산

### 좀 더 간단한 코드
- 먼저 n / k 값을 저장 한 후, 나머지가 있으면 +1 만 해주는 형식으로 개선 가능

```
// 기존
if (n % k == 0)
{
    x = n / k; 
}
else
{
    x = n / k + 1;
}

// 개선
x = n / k;

if (n % k != 0)
{
    x++;
}
```

> 둘을 비교해보니 cmp는 어쩌피 한 번이니까 성능상에서 큰 차이는 없을 것 같다

# range-based for
- string에서 각 원소에 접근 할 때, c++ 고수들은 range-based for문을 사용한다. 훨씬 간결하다.

- 인덱스로 연산을 하는 경우가 아니라면 range-based for문을 적극 사용하자.

### 절댓값
- std::abs 함수를 이용하자.
    - cstdlib, cmath에 포함됨.